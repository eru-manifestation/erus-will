Divido los cometidos de mi programa en módulos que cumplen su cometido independientemente:
* Módulo main:
    - Phase Rules: reglas que generan el comportamiento en fases
    - Clock: regla que gestiona el cambio de fases

* Módulo move-fellowship:
    Reglas relacionadas con el movimiento de una compañía

* Módulo corruption-check:
    Reglas que llevan a cabo el chequeo de corrupción a un personaje

* Módulo combat:
    Modela el combate contra una compañía

* Módulo elronds-council:
    Reglas que gestionan la verificación de condición de victoria

* Módulo organize-fellowship:
    Gestionan la organización de compañías

* Módulo tools:
    Contiene los constructos que representan la partida (objetos y template fase), 
    los eventos (para modificarlos y gestionar las subfases de los módulos), 
    acciones (tanto la definición como la implementación), constantes 
    globales (jugadores, manos, localizaciones), objetos auxiliares y sus reglas.


Como todos los módulos necesitan conocer el estado de la partida para funcionar,
todos deben importar los constructos necesarios del módulo "tools".

Todos los módulos excepto "main" y "tools" representan subtareas que necesitan resolución.
El módulo "tools" es sólo una utilidad, mientras que "main" representa el flujo y hechos que deben
ocurrir de forma consistente en cada una de esas fases.

Todos los módulos que representan acciones deben tener un punto único de entrada que debe
estar atento a la llamada que surja (como evento) desde cualquier punto o estado del programa.
Estas llamadas deben tener una saliencia alta, ya que no deben verse eclipsadas por
la ejecución de otra fase eventual inferior.

Al elegir que la saliencia se verifique al añadir la regla en la agenda, consigo que
las fases eventuales se ejecuten desde el inicio hasta el final, sin ser interrumpidas
por ninguna fase de ejecución inferior. Ex:

Se inicia la cadena de fases eventuales
MAIN --inicia combate-->  COMBAT --inicia corr. check--> CORR-CHK --inicia corr. check--> CORR-CHK2
                          MAIN                           COMBAT                           CORR-CHK
                                                         MAIN                             COMBAT
                                                                                          MAIN

Se resuelven de más reciente a más antigua
resuelvo CORR-CHK2 --> resuelvo CORR-CHK --> resuelvo COMBAT --> resuelvo MAIN

He utilizado varios enfoques para simular esta estructura encadenada:

PRIMER ENFOQUE:
Asimilo un módulo con el módulo CLIPS, lo cuál permite que el orden que marca la cadena de eventos
se respete de forma natural excepto cuando haya más de un evento del mismo tipo. Para estos casos,
las reglas que rigen el manejo de estas fases eventuales (fases lanzadas a partir de eventos) deben
tener saliencia descrita a la hora de declarar la instancia de esa regla.

Resolver MAIN implica retomar el flujo normal de la fase, sin reiniciar la agenda
(ya que cada módulo tiene su propia agenda). Las fases eventuales no se ven entorpecidas
entre ellas en su ejecución (si son de módulos distintos, porque no comparten agenda, y si
son del mísmo módulo porque la saliencia dinámica indicará que tendrá mayor saliencia siempre
el hilo de ejecución más arriba en el focus-stack. Al final del hilo de ejecución del módulo
siempre debe hacer un pop-focus para evitar saltarse el orden de ejecución marcado por
el focus-stack).

Ejemplo funcional:
(clear)
(watch focus)
(watch rules)
(set-salience-evaluation when-activated)
(defmodule MAIN (export ?ALL))
(deftemplate fire
    (slot letter) (slot any))
(defmodule B (import MAIN ?ALL))
(defrule set-B (declare (auto-focus TRUE) )
    (fire (letter B))
    =>
)
(defrule print-B (declare (auto-focus FALSE)(salience (length$ (get-focus-stack))))
    (fire (letter B))
    =>
    (println Se imprime B)
    (pop-focus)
)
(defmodule C (import MAIN ?ALL))
(defrule set-C (declare (auto-focus TRUE))
    (fire (letter C))
    =>
)
(defrule print-C (declare (auto-focus FALSE)(salience (length$ (get-focus-stack))))
    (fire (letter C))
    =>
    (println Se imprime C)
    (pop-focus)
)
(assert (fire (letter B) (any 1234)))
(assert (fire (letter C) (any DSKA4)))
(assert (fire (letter B) (any 1FDKJE)))
(run)
(println "Se ejecuta primero el hilo de ejecución B con evento fire-B-1234")
(println "Luego el hilo de ejecución C con evento fire-C-DSKA4")
(println "Finalmente, el hilo de ejecución B con evento fire-B-DSKA4")



En este ejemplo, cada fase eventual inicia el hilo de ejecución mediante un punto único
de entrada, con auto-focus, que cambiará el focus a su módulo, para que las reglas de dicho
módulo, sin auto-focus, manejen el hilo de ejecución sin intervenciones externas.

El módulo main no tiene ninguna regla con auto-focus, ya que proseguirá su ejecución
cuando hayan terminado todos los demás módulos.
Importante, recordar que el reloj debe tener saliencia inferior a las reglas de fase.

El módulo utils contiene sólo reglas de uso auxiliar, que tienen como objetivo facilitar
la programación. Deben tener SALIENCIA MÁXIMA y poder ser llamadas desde cualquier punto
del programa, con auto-focus.

Este método tiene varios inconvenientes: su funcionamiento es poco claro y es propenso a errores,
ya que hay que concretar una cifra de antemano que diferencie el orden, lo cual limita y puede llegar
a obstaculizar la saliencia de las reglas extra que se añadan al juego.

Ex: Siendo la primera cadena el nombre de la fase eventual y el número, la saliencia básica de sus
reglas
MAIN 0 -->  COMBAT 100 --> CORR-CHK 200 --> CORR-CHK2 300
            MAIN 0         COMBAT 100       CORR-CHK 200
                           MAIN 0           COMBAT 100
                                            MAIN 0

Ocurre que si alguna regla dentro de alguna de estas fases tuviese un incremento de saliencia mayor
a 99 o menor a 0, el orden entre esta y otras de fases con distinta prioridad podría intercambiarse, 
lo que daría lugar a un funcionamiento incorrecto.


SEGUNDO ENFOQUE:
Si bien hay algunos conceptos que pueden permanecer (como la simplificación de la agenda mediante
su división en módulos o el punto único de entrada para cada fase eventual), hay otros, como la gestión
de las saliencias que resulta enrevesada y propensa a fallos. Además, queda sin solventar el tema de
los hechos auxiliares cruzados entre distintas fases eventuales.

Este nuevo enfoque añade unas modificaciones: no se distinguirán fases eventuales según saliencias,
sino mediante activaciones. Cada objeto descriptor de fase eventual debe tener dos campos extra:
uno booleano que indique si está activo o no y otro de tipo fact-address, que contenga el nombre de
la fase eventual de la que fue llamado (de haberla, pues puede haber sido llamado desde MAIN o TOOLS?).

Por tanto, al iniciar cada fase eventual, debe "desactivar temporalmente" la fase de la que proviene
al iniciarse y "llamar" al descriptor de la fase eventual de donde provino al terminar su ejecución
(ya sea de forma abortada o satisfactoria).

Esta es una estructura muy flexible, pero además necesita proveer al programa de solidez y estabilidad,
debido a que el estado del programa debe ser congruente tanto tras el aborto como la finalización
satisfactoria de la fase eventual.

Se demandan 3 objetivos:
    -- Punto único de entrada, en el cual se active el descriptor de la fase eventual tras haber
        guardado la información y desactivado temporalmente el descriptor de la fase eventual de
        donde provino (de haberla)
    -- Punto único de salida, QUEDA POR DEFINIR SI DEBE SER MEDIANTE UN RECOLECTOR DE BASURA O LA
        AUTODESTRUCCIÓN DEL DESCRIPTOR POR SÍ MISMO, pero en algún punto, debe eliminarse el
        descriptor definitivamente.
    -- Control de estructuras de datos auxiliares, las cuales deberán tener como primer dato
        SIEMPRE la dirección del descriptor de fase eventual del que forman parte. Esto no solo
        ayuda a su manejo y distinción entre datos auxiliares de otras fases eventuales similares,
        sino que simplifica su destrucción en caso de abortado.